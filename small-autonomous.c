#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  LeftDriveEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  RightDriveEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  RightArmEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           rightDriveMotor,    tmotorVex393HighSpeed_MC29, openLoop, reversed,encoderPort, I2C_2)
#pragma config(Motor,  port6,           rightArmMotor,     tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port7,           leftArmMotor,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           clawMotor,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           leftDriveMotor,     tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* ---------------------------------------------------------------------------
 ** small-autonomous.h
 ** Skeleton class for the autonomous code.
 **
 ** Author: James Taylor
 ** -------------------------------------------------------------------------*/

task drive() {
	writeDebugStreamLine("> Started Drive task");
	while (true) {
		wait(5);
	}
}

task manipulator() {
	writeDebugStreamLine("> Started Manipulator task");
	while (true) {
		wait(5);
	}
}

task main() {

	setup();

	writeDebugStreamLine("\n\n>> Beginning Autonomous Subroutine\n");
	StartTask(drive);
	StartTask(manipulator);

	// needed to prevent the main task from terminating
	while (true) {
		wait(5);
	}

}

// ~ Global Definitions .......................................................

void setup() {
	nMotorEncoder[leftDriveMotor] = 0;
	nMotorEncoder[rightDriveMotor] = 0;

	nMotorEncoder[rightArmMotor] = 0;

	motor[rightDriveMotor] = 0;
	motor[leftDriveMotor] = 0;
}

void wait(int seconds) {
	wait1Msec(seconds * 1000);
}

// ~ Driving Definitions ......................................................

void turnRight(int angle) {

	// TODO angle to distance conversion
	move(63, -63, distance);
}

void turnLeft(int angle) {

	// TODO angle to distance conversion
	move(-63, 63, distance);
}

void moveForward(int distance) {

	move(63, 63, distance);
}

void moveBackward(int distance) {

	move(-63, -63, distance);
}

void move(int rightDrive, int leftDrive int distance) {

	nMotorEncoder[leftDriveMotor] = 0;
	nMotorEncoder[rightDriveMotor] = 0;

	encodistance = distance; // Write a conversion equation for the distance to encoder values, current one is temporary
	while (abs(nMotorEncoder[leftDriveMotor]) < encodistance)
	{
		motor[rightDriveMotor] = rightDrive;
		motor[leftDriveMotor] = leftDrive;
	}

	motor[rightDriveMotor] = 0;
	motor[leftDriveMotor] = 0;
}

// ~ Arm Definitions ..........................................................

int previous_height;

void arm(int height) {

	if (height > previous_height) {
		arm(127, 127, height - previous_height);
	} else {
		arm(-127, -127, previous_height - height);
	}
}

void arm(int rightArm, int leftArm, int delta_height) {

	nMotorEncoder[rightArmMotor] = 0;

	while (nMotorEncoder[rightArmMotor] < delta_height * 10)
	// TODO the distance conversion goes here
	{
		motor[rightArmMotor] = rightArm;
		motor[leftArmMotor] = leftArm;
	}

	motor[rightArmMotor] = 0;
	motor[leftArmMotor] = 0;
}

// ~ Claw Definitions .........................................................

void clawOpen() {

	motor[clawMotor] = -127;
	wait(2);
	motor[clawMotor] = 0;
}
void clawClose() {

	motor[clawMotor] = 127;
	wait(2);
	motor[clawMotor] = 0;
}
