#pragma config(Motor,  motor1,          leftFrontDrive, tmotorVexIQ, PIDControl,reversed, encoder)
#pragma config(Motor,  motor2,          leftRearDrive, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          rightFrontDrive, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor4,          rightRearDrive, tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* ---------------------------------------------------------------------------
 ** small-autonomous.h
 ** Skeleton class for the autonomous code.
 **
 ** Author: James Taylor
 ** -------------------------------------------------------------------------*/
task main() {

	setup();

	writeDebugStreamLine("Beginning TEK Robotics Autonomous Subroutine");

	StartTask(drive);
	StartTask(manipulator);

	while (true) {
		wait(5);
	}

}

task drive() {
	while (true) {
		wait(5);
	}
}

task manipulator() {
	while (true) {
		wait(5);
	}
}

// ~ Global Definitions .......................................................

void setup() {
	nMotorEncoder[rightDriveMotor] = 0;
	nMotorEncoder[rightArmMotor] = 0;
}

void wait(int seconds) {
	wait1Msec(seconds * 1000);
}

// ~ Driving Definitions ......................................................

void turnRight(int angle) {

	// TODO angle to distance conversion
	move(127, -127, distance);
}

void turnLeft(int angle) {

	// TODO angle to distance conversion
	move(-127, 127, distance);
}

void moveForward(int distance) {

	move(127, 127, distance);
}

void moveBackward(int distance) {

	move(-127, -127, distance);
}

void move(int rightDrive, int leftDrive int distance) {

	nMotorEncoder[rightDriveMotor] = 0;

	while (nMotorEncoder[rightDriveMotor] < distance * 10)
	// TODO the distance conversion goes here
	{
		motor[rightDriveMotor] = rightDrive;
		motor[leftDriveMotor] = leftDrive;
	}

	motor[rightDriveMotor] = 0;
	motor[leftDriveMotor] = 0;
}

// ~ Arm Definitions ..........................................................

int previous_height;

void arm(int height) {

	if (height > previous_height) {
		arm(127, 127, height - previous_height);
	} else {
		arm(-127, -127, previous_height - height);
	}
}

void arm(int rightArm, int leftArm, int delta_height) {

	nMotorEncoder[rightArmMotor] = 0;

	while (nMotorEncoder[rightArmMotor] < delta_height * 10)
	// TODO the distance conversion goes here
	{
		motor[rightArmMotor] = rightArm;
		motor[leftArmMotor] = leftArm;
	}

	motor[rightArmMotor] = 0;
	motor[leftArmMotor] = 0;
}

// ~ Claw Definitions .........................................................

void clawOpen() {

	motor[clawMotor] = -127;
	wait(2);
	motor[clawMotor] = 0;
}
void clawClose() {

	motor[clawMotor] = 127;
	wait(2);
	motor[clawMotor] = 0;
}
