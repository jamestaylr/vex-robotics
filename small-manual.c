#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  leftDrive,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightDrive,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftMotor,     tmotorVex393HighSpeed_MC29, PIDControl, reversed, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port4,           rightMotor,    tmotorVex393HighSpeed_MC29, PIDControl, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port5,           frontMotor,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           backMotor,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           clawMotor,     tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* ---------------------------------------------------------------------------
 ** small-manual.c
 ** Skeleton class for the manual remote control code.
 **
 ** Author: James Taylor & Keith Tiemann
 ** -------------------------------------------------------------------------*/

int SERVO_SPEED = 63;

task main() {

	int threshold = 25;

	while (true) {

		// Driving control

		if (vexRT[Ch3] > threshold || vexRT[Ch3] < -threshold) {
			motor[leftMotor] = vexRT[Ch3];
		} else {
			motor[leftMotor] = 0;
		}
		if (vexRT[Ch2] > threshold || vexRT[Ch2] < -threshold) {
			motor[rightMotor] = vexRT[Ch2];
		} else {
			motor[rightMotor] = 0;
		}

		// Lift control

		if (vexRT[Ch2] > threshold || vexRT[Ch2] < -threshold) {
			motor[frontMotor] = vexRT[Ch2];
			motor[backMotor] = vexRT[Ch2];
		} else {
			motor[frontMotor] = 0;
			motor[backMotor] = 0;
		}

		if (vexRT[Btn6U] == 1) {
			motor[clawMotor] = 127;
		} else if (vexRT[Btn5U] == 1) {
			motor[clawMotor] = -127;
		} else {
			motor[clawMotor] = 0;
		}

	}
}
